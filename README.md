# 数据结构与算法

## 基础

* 广义上的算法就是解决问题的方法，这是任何领域都需要考虑的问题，但是为什么只有信息领域如此强调呢？主要因为信息领域存在大量类似的问题，一个合适的算法优化可以带来极大的效用提高，相比之下，其它领域的问题缺少同质性。
* 程序设计=数据结构+算法。
* 算法的精髓：所有可以降低问题复杂度的算法都是在寻找一种划分，使得问题熵减。
  * 程序设计的三种基本结构：顺序结构、分支结构、循环结构。其中循环结构不会降低复杂度，因为它是用相同的策略来应对不同问题，而分支结构通过一定的划分，可以将问题（情况）分为不同的类，而不同的类有着更加明显的规律，可以用更加针对性的策略达到效果。
    * 二分：将情况分为两类，一类直接解决
    * 动态规划：通过一种解决顺序，可以将许多问题分到已经解决过的问题中
    * 回溯剪枝：通过判断，一类直接解决
* **计算机解决问题唯一的解决办法就是穷举**，穷举所有可能性。算法设计就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。或者说人也是如此。
  * 思考如何穷举就是证明问题是可以解决的，得到baseline方法；
  * 追求聪明的穷举就是通过加入先验知识，对各种情况特殊处理，降低计算成本。
* 实际的问题千千万万，我们不能记住所有具体的解决方案；但每个问题都可以抽象、分解为一些基本典型问题，只需要掌握这些基本问题的应对策略，就可以应对无穷的由基本问题组合而成的问题；这些基本问题也就是机器学习中的泛化特征。

### 问题思路

* 问题建模；
* 选择并描述算法；
* 证明算法是否能在所有实例上取得最优解；
* 分析算法效率。

### 算法要求

**基础要求**

* 正确性：零到多个输入，至少一个输出（广义上的输出）；
* 有穷性；
* 确定值；
* 可行性。

**重要要求**

* 可读性；
* 鲁棒性（能适应更加严苛、复杂的情况）；
* 时间空间复杂度低。

**算法层次**

* 没有语法错误；
* 对于合法输入能得到满足要求输出；
* 对于非法输入能够有合理应对；
* 对于故意刁难的输入可以得到满足要求的输出。

### 复杂度

**时间复杂度** 针对指定的基本运算和输入规模，算法所做运算的次数相对于输入规模的表达式。

* 基本运算应该满足：
  * 计算时间基本不变；
  * 在对应问题中其运算数量变化是影响运算时间的最主要因素。
  * 常见如：比较、加法、乘法、置指针、交换......
  * 常见的输入规模：数组元素多少、调度问题的任务个数、图的顶点数与边数......
* 复杂度中带$O(log(n))$的往往会用到二分或者类似二分的操作（树、堆）
* 复杂度中带$O(mn)$的往往需要for循环或动态规划计算
* 指数复杂度的场景往往输入规模极小，个位数量级

**空间复杂度** 针对指定的空间单位和输入规模，算法所需的空间量相对于输入规模的表达式。

> 时间复杂度和空间复杂度都是十分重要的，但是一般算法之间的空间复杂度差别远不及时间复杂度上的差别，因此更多比较的也是时间复杂度。

### 主定理

对于递推关系： $T(n)=aT(\frac{n}{b})+f(n),a>=1,b>1$ $n$为问题规模，$a$为子问题个数，$\frac{n}{b}$为子问题规模，$f(n)$为递归以外的计算工作。

$log\_ba$与$f(n)$直接影响复杂度

**情况一** 当$O(f(n)) < O(n^{log\_ba})$ 多项式地小于时：$O(n^{log\_ba})$主导复杂度，$T(n)=O(n^{logb(a)})$

**情况二** 当$O(f(n)) > O(n^{log\_ba})$ 多项式地大于时：$f(n)$主导复杂度，$T(n)=O(f(n))$

**情况三** 当$O(f(n)) = O(n^{log\_ba}log^{k}n)$差距不足多项式时，共同影响复杂度，$T(n)=O(n^{log\_ba}log^{k+1}n)$

注：部分复杂度符号使用粗略

### 遍历

* 广度优先：从一个节点开始，往外一层一层地拓展，第零层为起始节点，第一层为直接与起始节点相连的结点，第n层为直接与第n-1层相连但不属于前面任意一层地结点，直到遍历完所有节点。
* 深度优先：从第一个节点开始，随机查找下一个未被访问的节点，直到无法前进（走进死胡同），然后开始回退，一旦发现有未被访问的节点就继续前进，直到遍历所有节点。

### 递归

* 直接或间接调用自身的算法称为递归算法，必须有停止条件。
* 递归可以使得解决思路简洁、清晰；

**缺点**

* 有时候比较低效，经历大量的重算，可以用动态规划优化。
* 压入堆栈消耗更多空间
