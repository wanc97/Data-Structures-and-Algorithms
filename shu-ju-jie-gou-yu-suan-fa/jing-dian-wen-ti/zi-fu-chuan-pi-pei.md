---
description: BF、RK、BM、KMP、Trie树、AC自动机
---

# 字符串匹配

## **BF**&#x20;

时间复杂度很高$O(m\*n)$，但也很常用，因为：

* 大多数时候主串和匹配串的长度都不大；
* 大多数时候会较早遇到不匹配的情况然后停止；
* 实现简单不容易出错。

## **RK**

* 通过设计合适的哈希算法，将复杂度降低到$O(n)$；
* 没有散列冲突的哈希算法可能会整形溢出，可以允许有一定的冲突，平衡空间与时间

## **BM**&#x20;

实验统计，BM的性能是著名的KMP算法的3到4倍

## **KMP算法**

* KMP算法相对于单纯的滑动比较，主要改进在于发现最长公共前后缀在冲突时的作用，进而通过动态规划的方式避免重复劳动，降低复杂度。
* 在比较冲突的时候，已经比较配对的部分中匹配串与模式串是相同的，因此接下来的滑动相当于是已匹配部分自己与自己比较，即寻找最长公共前后缀。
* 最长公共前后缀与模式串的字符位置对应，因此记录最长公共前后缀信息的数组就是next数组，也是动态规划中的Memory。
* 计算next数组的过程就是动态规划的过程，当连续匹配时next数组可以依次写出，当出现不匹配时直接调用以计算出的部分即可。
* 所以KMP算法是一种动态规划的实现，以空间换时间，用next数组记录运算信息，避免重复子问题。
