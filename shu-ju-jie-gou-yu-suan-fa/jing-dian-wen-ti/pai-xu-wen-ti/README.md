# 排序问题

## **时间复杂度**

* 时间复杂度为$$O(n^2)$$的排序算法有：冒泡排序、选择排序、插入排序

> 这些排序算法是很直观的做法，但效率都比较低，随着元素数量增加，计算代价迅速增加，有优化的空间。例如这些算法在执行的时候，原数组会开始变得有序，这种有序就可以加以利用，进而降低复杂度，也就有了$$O(nlog(n))$$的算法。进一步如果待排序元素的种类/个数是有限的，还可以利用桶进一步降低复杂度。

* 时间复杂度为$$O(nlog(n))$$的排序算法有：快速排序、归并排序、堆排序、希尔排序
* 时间复杂度为$$O(n+k)$$的排序算法有：计数排序、基数排序

## **冒泡排序**

* 自然界中，在重力作用下密度小的物体有向上运动的趋势，而密度大的物体有向下运动的趋势，也就是自然存在依密度排列的趋势。
  * 冒泡排序的思路就是这么朴素，让元素按大小自然沉浮。
  * 对于长度为$$n$$的数组，循环$$n-1$$次，每次都让剩下元素中最大的元素沉下去（当然可以让最小的浮上来）。

## **选择排序**

* 同样对于长度为n的数组，循环$$n-1$$次，每次遍历剩下元素，把最大（最小）地元素提取出来。
* 与冒泡排序类似，不同的是冒泡每次比较发现逆序都会交换元素，而选择排序会记录当前的最大值的位置。

## **插入排序**

* 对于长度为$$n$$的数组，循环$$n-1$$次，每次从剩下元素取第一个往有序部分**线性**插入。
* 选择排序是在取的时候得到有序，而插入排序是在放的时候得到有序。
* 在数组是由链表构成时，如果插入的时候不是线性插入，而是二分插入（数组不能二分插，还是要搬运各个元素，链表可以借助跳表），可以将复杂度降到$$O(nlog(n))$$

## **快速排序**

* 利用二分和分治的思想，大约循环$$log(n)$$层，每次将原数组划分成两个无序部分，但是其中一个部分都大于另一个部分。
* 可以看成是一种特殊的冒泡排序，所有元素跟相同的元素比较，使得每次比较一遍可以让所有元素都**沉**或**浮**。
* 还可以看成是一种前序遍历，根节点完成划分，两个子节点完成子数组的排序；
* 快排每次划分不一定是在中间，需要记住划分位置，所以空间复杂度为$O(log(n))-O(n)$，如果用递归，空间复杂度就是递归深度，如果是迭代做，空间复杂度就是记住划分位置。

```python
def partition(arr, low, high):
    i, j = low, low 
    pivot = arr[high] # 取最后一个元素当做pivot
    while j < high:
        # 当前元素小于或等于 pivot
        if arr[j] < pivot:
            arr[i], arr[j] = arr[j], arr[i]
            i += 1 #pivot位置前进1步
        j += 1
    arr[i], arr[high] = arr[high], arr[i] #将pivot放到正确的位置并返回位置索引i
    return i
# 快速排序函数
def quick_sort(arr, low, high):
    if low < high:
        pi = partition(arr, low, high)
        quick_sort(arr, low, pi - 1)
        quick_sort(arr, pi + 1, high)
 
arr = [1,10,2,7, 8, 9,1, 5]
# arr = [1,1,1,1,1]
quick_sort(arr, 0, len(arr)-1)
print(arr)
```

## **归并排序**

* 利用分治的思想，将问题划分为更小的子问题，$问题数量的增长+额外代价 < 问题复杂度的减小$时就可以降低复杂度。
  * 这里随着分治的进行，问题数量指数增加，问题复杂度指数减小，但是问题复杂度减小地更快。
  * 空间复杂度$O(n)$
* 也可以看成后序遍历，子节点完成前后两部分的排序，根节点完成合并。

## **堆排序**

* 利用最大/小堆，每次弹出最大/小值，可以看成是一种优化的选择排序。
* 建立堆的过程复杂度为$O(n)$：不同结点需要比较的次数不一样，但平均不超过2。

## **希尔排序**

* 当原数组是非常有序时，插入排序的复杂度极低，可以接近$O(n)$。希尔排序是一种改良的插入排序，先通过较大的步长尽可能减少逆序，降低插入的代价。
* 复杂度与步长选择有关，当原数组较为有序时可以考虑小一些的步长；当步长不合适时复杂度会增加至$O(n^2)$。
* 当数据量过大时，希尔排序容易低效，更适合数据量小的时候。

## **计数排序**

* 当排序数组的元素取值为有限值时，可以根据可能的取值构建桶，将元素按值放入桶中，对桶中的元素计数，得到元素的顺序，是一种在特殊情况下以空间换时间的方式。

## **基数排序**

* 在元素取值为有限位时，从低位到高位，每次对其中一位进行排序。
* 两种桶排序的空间复杂度跟桶的数量有关。
