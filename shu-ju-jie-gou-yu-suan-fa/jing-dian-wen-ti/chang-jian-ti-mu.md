# 常见题目

## m数之和

* 排序+左右指针：
  * m=2：排序，左右指针从两边向中间移动，复杂度$O(nlog(n))$；
  * m>2：排序，从第一个数的取值开始循环，每一层循环m降低一，最后调用两数之和，左右指针从两边向中间移动，复杂度$O(n^{m-1})$；
* 哈希+遍历比较：哈希计算并记录m//2数之和的可能性，然后遍历并记录，最坏的时间复杂度$O(n^{m//2+1})$，实际可能更低；

## 发糖果

* 问题：给一个列表，是孩子的评分，给孩子发糖果，要保证评分高的孩子得到的糖果数比两边评分低的孩子多
* 解决：左右各遍历一次，记录给每个孩子最少的糖果，取最大值。

## 蓄水池采样

* 问题：数据流式到达，总数$n$未知，从中采样$k$个，保证每个数据被采样的概率都是$\frac{k}{n}$；
* 解决：前$k$个数据直接保存，第$m$个数据到达时，以$\frac{k}{m}$的概率替代当前保留数据，使得所有数据等概率；

## 素数数量

* 统计区间$\[2,n)$的素数个数,外循环从小到大寻找素数，内循环将其倍数标注为非素数；
* 外循环只需要遍历到$\sqrt n$的位置，内循环只需要从$i^2$开始遍历；

```python
def count_primes(n):
    is_primes = [True for _ in range(n)]
    for i in range(2, int(n**0.5)+1):
        if is_primes[i]:
            for j in range(i**2, n, i):
                is_primes[j] = False
    return sum(is_primes)-2
```

## 阶乘后面的0

* 任意一个数的阶乘，后面有多少个0，其实是看有多少个2,5组合，2远多于5，所以只看5

```python
def trailingZeroes(n):
    zero_count = 0
    while n > 0:
        n //= 5
        zero_count += n
    return zero_count
```

* 有k个0的阶乘有多少个，在上一个问题的基础上，通过二分查找确定边界，然后定位；

## 取模问题

* 当问题规模较大时，可能出现溢出的情况或有其它要求，希望结果取模；
* 考虑到性质：$(a \* b)\\%k=(a\\%k)\*(b\\%k)\\%k$，可以将取模运算放在计算前，以避免溢出；
