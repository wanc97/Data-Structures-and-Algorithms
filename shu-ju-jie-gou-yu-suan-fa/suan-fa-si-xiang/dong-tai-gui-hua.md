# 动态规划

## **基本思想**

* 基本思路：**穷举**+**备忘录**
  * 穷举是为了比较所有可能的情况，每一个问题可以由一系列小问题的答案组合而成，一般是$max(dp\[小1],dp\[小2],...)$。
  * 备忘录是通过记录子问题的结果，避免重复计算，用空间换时间，降低时间复杂度
* 重点是穷举过程的**转移方程**，也就是将原问题转化为更简单的子问题的转移关系，一定要正确
  * 正确得到穷举的转移方程需要明确问题的变量（自由度），最后的问题就变成了多维（自由度）数组的元素填充问题。
* 穷举方向可以是**自顶向下**的**递归**，也可以是**自底向上**的**迭代**
* 一个优化角度是**穷举顺序**，合适的穷举顺序可以少使用备忘录，降低空间复杂度
* 对于有指数种情况的问题:要么是可以用动态规划来求解;要么就只能应用在输入规模极小的场景；或者可以在回溯中大量剪枝。

## **通用框架**

```python
# 自底向上
dp = ...
for 状态1 in 状态1取值:
    for 状态2 in 状态2取值:
        for ...:
            dp[状态1][状态2][...] = 择优(选择1,选择2,...)
# 自顶向下
memory = ...
def dp(状态1,状态2,...):
    if 状态1,状态2,... not in memory:
        memory[状态1][状态2][...] = 择优(dp(选择1),dp(选择2),dp(...))
    return memory[状态1][状态2][...]
```

## **常见题目**

* 凑零钱问题：状态是总的钱数，子问题是减去可能的零钱后的钱数，优化的是最少零钱数；
* 0-1背包问题：状态是背包容量与待装物品，子问题是某个物品装与不装后的背包容量和剩下的待装物品，优化的是总价值；
* 股票买卖：状态是每一天的买卖情况、第几次买卖等，子问题是前一天或前几天的状态，优化的是最终收益。
* 最小路径和：状态是二维平面上每一个点的最小路径，子问题是前面点的最小路径，优化的是目的地的最小路径。
* 编辑距离：状态是两个字符串的子串的编辑距离，子问题是通过几种可选择的操作可以得到的子问题，优化的是编辑距离。
* 最长公共子序列：状态是两个字符串的子串的最长公共子序列，子问题是减掉一两个字符串最后一个字符得到的。
* 最长回文子序列：状态是字符串的子串的最长回文子序列，子问题是从左右两端减掉一两个字符后的最长回文子序列。
* 最长上升子序列：状态是索引，子问题是每个位置前所有元素中，包括这个位置的最长上升子序列。
* 得分数组左右取分，预测赢家，状态是剩下数字的起始和结束位置；
* 为运算表达式设计优先级：子问题是一段表达式可能的优先级；
