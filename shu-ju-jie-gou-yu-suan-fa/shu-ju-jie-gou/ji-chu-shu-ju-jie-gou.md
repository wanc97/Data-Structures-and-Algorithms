# 基础数据结构

## 数组

**特殊数组**

* 前缀和数组：等于原数组的积分，适用于频繁使用数组一段区间大小的情况；
* 差分数组：等于数组的差分，适用于数组频繁对一段区间的值进行共同加减操作的情况；

**常见题目**

* 删除数组重复元素、删除数组指定元素、移动指定元素：双指针，快指针寻找元素，慢指针指示位置；
* 数组和为 k 的子数组：
  * 元素为正：
    * 左右指针滑窗：$$O(n)$$时间复杂度，遍历一次即可；
  * 任意元素：
    * 前缀和数组：空间$$O(n^2)$$，时间$$O(n)$$；
    * 哈希表代替前缀和数组，空间时间都是$$O(n)$$
* $$O(1)$$时间随机获得元素，要将元素紧凑的存在数组中；
* 查找缺失元素：长度为n的序列，包含0\~n之间的数，每个数字出现一次，找到没有出现过的数；
  * 排序：时间$$O(n*log(n))$$，空间$$O(1)$$
  * 哈希表记录：时间$O(n)$，空间$O(n)$
  * 异或：时间$O(n)$，空间$O(1)$
  * 求和：时间$O(n)$，空间$O(1)$

## 字符串

字符串可以看成数组，区别在于当它以字符串形式出现时，不适合直接操作单个字符；但当以字符数组出现时可以，与数组几乎完全一致。 **常见题型**

* 规则判断：是否是回文、是否符合整数、能否转化为数值、能否转化为算式；
* 字符计数：哈希表、固定长度数组（字符数量有限）、滑动窗、无重复最长子串；
* 动态规划：最长公共（回文）子串（子序列）；

**常见题目**

* 二叉树匹配：判断一棵树是否是另一棵树的子结构
  * 暴力解法：递归地对匹配树的每一个结点，与模式树进行比较，复杂度$O(n\*m)$。
  * 最佳解法：树的序列化+KMP算法，复杂度$O(n+m)$，将树变为字符串，然后进行字符串匹配，树的序列化要正确，具有唯一性，一对一映射。
* 两个字符串是否为变形词：使用哈希表或数组记录每个字符出现的次数进行比较，可以只用一个哈希表或数组记录其中一个的字符串的字符次数，然后遍历另一个字符串，做减法，遇到负数还可以提前结束。
* 两个字符串是否为旋转词：在长度相等的情况下，将一个字符串重复两次（这样包含了所有旋转词的情况），然后用KMP判断是否包含另外一个词，复杂度$O(n)$。
* 字符串单词逆序：
  * Python一行：split，翻转，拼接；额外空间
  * 两次翻转：遍历，对每个单词翻转；然后对整个字符串翻转，如果是字符数组时，不用额外空间。
* 字符串前后调换：
  * Python一行：额外空间
  * 两次翻转：同上
* 字符串数组字典排序：不能直接比较字符串的字典序，而要将两个字符串拼接比较，看哪个应该在前面。
* 字符串替换：将字符串中的字符替换成字符串，字符串会变长，可以先遍历一遍，看看有多少符合的字符，然后从后往前填充。
* 括号字符串是否有效：
  * 如果只有一种括号，可以遍历并记录左右括号的数量，空间复杂度$O(1)$；
  * 如果有多种括号，用栈，空间复杂度$O(n)$。
* 最长无重复子串：双指针遍历记录目前最长无重复子串，哈希表记录遍历元素最大位置，根据遍历元素位置调整指针。
* 字符串解析：可以用栈或更加方便地用递归；字符串括号等里面是独立的单元，可以调用递归；
* 保证相对顺序和字典序最小的字符串去重：贪心+单调栈；记录每个字符的出现次数，依次入栈，尽可能删除小字符前的字符，如果一个字符已经加进去了就不加；

## 链表

* 反转链表：
  * 迭代和递归都可以，迭代不需要额外空间，递归写起来简洁；
  * 迭代：从前往后遍历，存储几个必要节点，交换指向；
  * 递归：子函数实现递归，返回下一个节点反转后的头节点和尾节点；
* k个一组反转链表：边界判断 + 反转k个节点链表；
  * 迭代：从前往后遍历，有k个节点则调用子函数部分反转；
  * 递归：有k个子节点则调用子函数反转前面，调用自身处理后面，再整合；
* 反转部分链表：
  * 迭代：遍历至指定位置，执行指定数量反转；
  * 递归：传参数加入带反转的位置信息，以判断操作；
* 删除链表重复元素：有序链表直接遍历，无序用哈希表；

## 栈&队列

|      |             栈            |        队列       |
| :--: | :----------------------: | :-------------: |
|  进出  |           先进后出           |       先进先出      |
| 常用操作 | `pop、push、top/peak、size` | `pop、push、size` |
|  图搜索 |           深度优先           |       广度优先      |
| 编程结构 |            递归            |        迭代       |

**栈**

* 后进先出，因为操作都是在栈的顶部完成，且需要频繁改动，所以可以用单链表实现，各种操作都是$O(1)$时间。
* 如果用单链表实现栈，则入栈时单链表往头部方向扩展。
* 如果用数组来实现栈，当栈的长度超过数组长度时，运算复杂度不再是$O(1)$。
* 使用栈的场合往往是主要关注上一个操作的。

**队列**

* 先进先出，常用于顺序处理问题的场合，如：广度优先搜索。
* 双端队列可以利用双链表来实现，在队列的两端都用$O(1)$的时间进行查询、增加、删除。常用于长度动态变化的窗口或区间。
* 循环队列的一个好处是可以固定长度的数组实现。

**单调栈**

* 递减子数组数目；
* 滑窗最大值；
* 下一个更大元素；
* 下一个更大元素的距离（存储下标）
* 循环数组的下一个更大元素：让原数组重复一次；

**常见题目**

* 设计一个能够在$O(1)$时间复杂度返回最小元素的栈：可以设计一个额外记录最小值的栈，记录当前位置的最小值，额外空间复杂度$O(n)$；只在弹入值小于等于当前最小值时压入记录最小值的栈；
* 用两个栈实现队列：两个先进后出就可以得到先进先出，一个栈接收数据，一个栈倒出数据，但是从第一个往第二个倒的时候第二个栈必须是空的，且一次倒完。
* 栈的逆序：
  * 用递归函数实现：一个递归函数实现删除/弹出栈底元素，第二个递归函数调用第一个递归函数递归删除到最后后逆序压入，时间复杂度高；
  * 用队列实现：依次弹出栈元素，放入队列，从队列中取出压入栈；队列先进先出，而栈后进先出的特性带来了逆序。
* 用一个额外的栈实现栈中元素排序：原理就是让元素倒来倒去，让元素有序；原理类似于插入排序。
* 数组取划窗最大值：双端队列，存放元素下标，压入的时候比较，去掉不符合的，同时从一端获得最大元素的下标。

## 树

* 完全二叉树适合数组存储
* 可视为一个拥有N 个节点和N-1 条边的一个有向无环图。 **遍历**
* 一般采用递归的方法遍历比较清晰，二叉树遍历分为：前序遍历、中序遍历、后序遍历
* 树的遍历得到的结果并非一一对应，不同的树可以得到相同的遍历结果。
* 很多问题一旦写成递归形式都可以看成树的遍历，快排-前序遍历、归并排序-后序遍历、回溯-决策树DFS遍历
* 二叉树相关的题大多可以通过写成递归遍历的形式快速解决；

```python
/* 二叉树遍历框架 */
def traverse(root):
    // 前序遍历
    traverse(root.left)
    // 中序遍历
    traverse(root.right)
    // 后序遍历
```

**常见题目**

* 反转二叉树、二叉树展开为链表、求二叉树高度
* 通过列表、前中后序遍历重构二叉树
* 寻找重复子树：后序遍历+序列化+哈希
* 二叉树的节点数：
  * 任意二叉树：遍历+计数，$O(n)$；
  * 满二叉树：找深度，$O(log(n))$：
  * 完全二叉树：判断+用任意二叉树和满二叉树的方式，$O(log(n)\*log(n))$；
* 二叉树最长路径：状态是每一个节点的优化值，子问题是子节点的优化值。

## 哈希表

* 一种使用哈希函数组织数据，以支持快速插入和搜索的数据结构。
* 哈希+大数组\[+链表]

#### 堆

* 完全二叉树（适合数组存储）；
* 每个节点的值大于等于（小于等于）子树的值。

堆删除元素是弹出堆顶元素，将末尾元素放到堆顶，然后从上往下堆化；堆插入元素是将待插入元素放置在堆末尾，然后从下往上堆化。

**堆排序VS快速排序**

* 快排顺序遍历，对cache更加友好，堆排序随机访问，对cache不友好；
* 堆排序会打乱原有顺序，增加逆序度，因此实际中的交换次数可能更多。

**堆的应用**

* 求最值，排序；
* 合并多个有序序列；
* 高性能定时器，获取需要执行的任务，不需要反复轮询；
* 求topk大元素，只需要建一个大小为k的小根堆，每次新来元素同堆顶元素比较，如果大于堆顶元素就替换，否则不操作；
* 动态求中位数，一个大顶堆存小元素和一个小顶堆存大元素，保持两个堆元素数量平衡，即可快速，动态得到中位数。

## 图

**基本概念**

* 图可以用邻接矩阵、邻接表来表示。
* 无向图：$G=(V,E)$,V表示结点，数量为n，E表示边，数量为m。
* 有向图：图$G=(V,E)$的边是带有方向的，如网页超链接。
* 路径（path）：无向图$G=(V,E)$中的路径定义为由一系列结点构成的序列，其中两个连续结点之间有一条边。
* 简单路径：所有节点都是不相同的。
* 连通无向图：任意两个结点之间存在一条路径。
* 圈/环：有且只有首尾为相同结点的路径。
* 有向无环图：不包含有向环的有向图。
* 树是连通且不包含圈/环的无向图。
* 对于有n个结点的无向图，这三条中任意两条可以作为树的定义并推导出第三条：连通，边数为$n-1$，没有圈。
* 二部图/二分图：如果一个无向图的结点用红蓝两种颜色区分，可以使得每条边的两个结点一个是红色一个是蓝色。
  * 如果一个无向图不包含奇圈，那就是二部图。
  * 广度优先遍历的结果中不包含连接同一层结点的边的无向图是二部图。
* 如果有向图两个结点之间相互可达，这两个结点是强连通的，如果有向图中所有结点是相互可达的，则此图是强连通的。
  * 任意一个结点与其它结点相互可达，这个图就是强联通的。
  * 判断方式：取一个点作为根节点做广度优先，边的方向反向再做广度优先，如果两次都可以到达所有点，则此图是强联通的。

**遍历**

* 广度优先遍历中，通过一条边连接起来的两个结点的层数最多相差一层。
